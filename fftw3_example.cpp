/**
 * large-fft.cpp
 * 
 * Description: This program demonstrates the use of the FFTW3 library to
 * perform a fast Fourier transform on a large data set.  The data set is
 * generated by reading in a file containing a sequence of 16-bit signed
 * integers.  The data is then transformed into a complex array and the
 * FFT is performed.  The resulting complex array is then transformed
 * back into a real array and the results are written to a file as an image.
 * 
 * The output is a PNG image file containing the magnitude of the
 * transformed data.  A waterfall image. The image is scaled so that the 
 * maximum value is white and the minimum value is black. Then Pseudo colored.
 * 
 * There is a second output called the raw data file.  This file contains
 * the power of each output data sample as a 32-bit float. This file can then
 * be used to plot the power spectrum of the input data using Python code,
 * perhaps. This raw file contains no header information. It is just a
 * sequence of 32-bit floats.
 * 
 * The input file is a 16-bit signed integer file containing many GBs of 
 * samples.
 * 
 * Care was taken to allocate and free memory efficiently so the program can
 * operate on large data sets with fairly large FFTs. The same was attempted
 * using scipy.fft but the memory requirements were too large for the system.
 * scipy.fft seems to have a bug where it caches data onto disk (maybe as swap)
 * quickly filling up the disk.  This program does not have that problem.
 * 
 * The input data is from a Moon bounce signal recorded at the Allen Telescope Array
 * in 2021.  The signal is a 1,296,25GHz series of 2 tones. We wish to anallyze
 * the interraction of the two tones. Various tone separation values were
 * transmitted from near Vancouver, Ca and received at the Allen Telescope Array.
 * Each tone separation, from 26 to 2 Hz, was transmitted for 1 minute intervals.
 * In between these intervals the transmitter needs to rest, it gets hot.  
 * 
 * The data we are using here is a one minute section of data that contains two
 * tomes separated by 22 Hz.  
 * 
 * The data was recorded using an Ettus SDR. The data was recorded at a sample
 * rate of 1,920,000 samples per second.  The data was recorded in 16-bit signed
 * integer format.     
 * 
 * Author:  Jon Richards - Quantum Astronomy Group, SETI Instute
 * Date:    January 8, 2023
 * 
 * Usage:   ./large-fft
 *          The input data file name is defined in the code. Edit RAW_DATA_FILENAME below.
 *          The output images file ames are defined in the code. Edit FFT_IMAGENAME.
 *          The output raw file names are defined in the code. Edit FFT_RAW_OUTPUT_FILENAME.
 * 
 * 
*/
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <time.h>
#include <stdbool.h> 
#include <iostream>

#include <fftw3.h>
#include <opencv2/opencv.hpp>
#include "opencv2/core/core.hpp"
#include <opencv2/core/mat.hpp>
#include "opencv2/highgui/highgui.hpp"


using namespace cv;

// Define the parameters of the data file
#define SAMPLES_PER_SEC 1920000
#define BYTES_PER_SAMPLE 4

// Note - the FFTW3 library will have issues if the FFT size is not a power of 2
// 2097152 = 2^21
// 2097152 results in an output resolution of 0.9155273438 Hz
#define FFT_SIZE 2097152
#define NUM_SECS 60 // Number of seconds to process from the file
#define OVERLAP 0.25 // The overlap between FFTs

// The signal of interest is in a small range of frequencies. So we will only
// save a small range of frequencies.  This will reduce the size of the
// output image.
#define START_CHAN (1211289 - 15 + 49)
#define END_CHAN (1211385 + 15 - 41)

const char *RAW_DATA_FILENAME = "data/raw_int16_iq.dat";
const char *FFT_IMAGENAME = "images/raw_int16_iq.png";
const char *FFT_RAW_OUTPUT_FILENAME = "fft_raw_data/raw_int16_iq.raw";

/**
 * @brief Open a file in binary mode
 * 
 * @param filename - the name of the file to open
 * @return FILE* - the opened file pointer
 */
FILE *openFile(const char *filename) {

    FILE *fp = fopen(filename, "rb");
    if (fp == NULL) {
        printf("Error opening file %s", filename);
        return NULL;
    }
    return fp;
}

/**
 * @brief Read a chunk of data from the file into fftw_complex* data.
 * 
 * @param fp - the already opened file pointer
 * @param num_seconds - the number of seconds to read
 * @return fftw_complex* - the data read from the file
 */
 fftw_complex *readData(FILE *fp, int num_seconds) {

    if(fp == NULL) {
        printf("Error: File pointer is NULL");
        return NULL;
    }
   
    // Calculate the number of bytes to read
    int bytes_in_chunk = num_seconds * BYTES_PER_SAMPLE * SAMPLES_PER_SEC;
    unsigned short *data = (unsigned short *)malloc(bytes_in_chunk);

    // Read in the data
    fread(data, bytes_in_chunk, 1, fp);

    // Close the file!
    fclose(fp);

    // Pack into fftw_complex
    fftw_complex *fft_data = (fftw_complex *)malloc(num_seconds * SAMPLES_PER_SEC * sizeof(fftw_complex));
    printf("Allocated %ld bytes for fft_data\n", num_seconds * SAMPLES_PER_SEC * sizeof(fftw_complex));
    for(int i = 0; i<num_seconds * SAMPLES_PER_SEC; i++)
    {
        fft_data[i][0] = (double)data[i*2];
        fft_data[i][1] = (double)data[i*2+1];
    }

    // Free the data array
    free(data);

    // Return the fftw_complex array
    return fft_data;
 }
  
  /**
   * @brief Calculate the FFT of a chunk of data
  */
int main(int argc, char const *argv[])
{
    fftw_complex *fft_in;
    fftw_complex *fft_out;
    fftw_complex *fft_data_chunk_from_file = NULL;
    fftw_plan fft_plan;

    int num_iterations = 0;
    int pos = 0;
    int x;

    // Initialize the FFTW library
    printf("Initializing FFT data\n");
    fft_in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * FFT_SIZE);
    fft_out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * FFT_SIZE);
    fft_plan = fftw_plan_dft_1d(FFT_SIZE, fft_in, fft_out, FFTW_FORWARD, FFTW_MEASURE);

    // Calculate the size of each bin
    double bin_size = (double)SAMPLES_PER_SEC / (double)FFT_SIZE;
    printf("Bin size = %lf\n", bin_size);

    printf("FFT_SIZE=%d\n", FFT_SIZE);
    printf("OVERLAP=%f\n", OVERLAP);

    // Scale the start and end channels based on the bin size
    int start_chan = (int)(START_CHAN/bin_size);
    int end_chan = (int)(END_CHAN/bin_size);
    int num_channels = end_chan - start_chan;
    printf("start_chan=%d\n", start_chan);
    printf("end_chan=%d\n", end_chan);
    printf("num_channels=%d\n", num_channels);

    // Create an accumulator array for the FFT data
    double *acc = (double *)calloc(FFT_SIZE, sizeof(double));

    // Define the Mat to store the 2d data
    //Calculate the number of iterations
    pos = 0;
    while(pos + FFT_SIZE < NUM_SECS * SAMPLES_PER_SEC) {
        pos += (int)(FFT_SIZE * (1.0-OVERLAP));
        num_iterations++;
    }
    Mat mat_data(num_iterations, num_channels, CV_32FC1);
    // Create the color map Mat
    Mat im_color;
    // Create the grayscale Mat
    Mat adjMap;

    //Create the windowing function, this is a Hanning window
    double *window = (double *)malloc(FFT_SIZE * sizeof(double));
    for(int i = 0; i<FFT_SIZE; i++) {
        window[i] = 0.5 * (1 - cos(2 * M_PI * i / (FFT_SIZE - 1)));
    }

    printf("Started\n");

   
    printf("Processing raw data file %s\n", RAW_DATA_FILENAME);

    ///////////////////////////////
    // Retrieve the data to process
    ///////////////////////////////

    // Open the file
    FILE *fp = openFile(RAW_DATA_FILENAME);
    if(fp == NULL) {
        printf("Error opening file %s, exiting.\n", RAW_DATA_FILENAME);
        return -1;
    }

    // Read in the the entire data for this chunk
    fft_data_chunk_from_file = readData(fp, NUM_SECS);
    if(fft_data_chunk_from_file == NULL) {
        printf("Error reading data");
        return -1;
    }
    // Close the file!
    fclose(fp);
    printf("Read samples from file\n");

    //////////////////
    //PROCESS THE DATA
    //////////////////

    // Clear the accumulator array
    memset(acc, 0, FFT_SIZE*sizeof(double));

    // Clear the Mat
    mat_data.setTo(cv::Scalar::all(0));

    pos = 0;
    num_iterations = 0;
    //fftw_complex *halfdata = (fftw_complex *)malloc(FFT_SIZE/2 * sizeof(fftw_complex));
    while(pos + FFT_SIZE < NUM_SECS * SAMPLES_PER_SEC) {

        //Progress indicator
        if (num_iterations % 100 == 0) {
            printf("Iteration %d\r\n", num_iterations);
            fflush(stdout);
        }

        // Copy the data into the fft_in buffer
        memcpy(fft_in, &fft_data_chunk_from_file[pos], FFT_SIZE * sizeof(fftw_complex));

        for(int i = 0; i<FFT_SIZE; i++) {
            fft_in[i][0] *= window[i];
            fft_in[i][1] *= window[i];
        }
    
        // Run the FFT
        fftw_execute(fft_plan);

        //remove dc
        fft_out[0][0] = fft_out[2][0];
        fft_out[0][1] = fft_out[2][1];
        fft_out[1][0] = fft_out[2][0];
        fft_out[1][1] = fft_out[2][1];
        fft_out[FFT_SIZE-1][0] = fft_out[FFT_SIZE-3][0];
        fft_out[FFT_SIZE-1][1] = fft_out[FFT_SIZE-3][1];
        fft_out[FFT_SIZE-2][0] = fft_out[FFT_SIZE-3][0];
        fft_out[FFT_SIZE-2][1] = fft_out[FFT_SIZE-3][1];
    
        //fft shift
        for(int i = 0; i<(int)(FFT_SIZE/2); i++) {
            double temp_real = fft_out[i][0];
            double temp_complex = fft_out[i][1];
            fft_out[i][0] = fft_out[i+(int)(FFT_SIZE/2)][0];
            fft_out[i][1] = fft_out[i+(int)(FFT_SIZE/2)][1];
            fft_out[i+(int)(FFT_SIZE/2)][0] = temp_real;
            fft_out[i+(int)(FFT_SIZE/2)][1] = temp_complex;
        }

        // Copy the desired channels into the Mat 2d storage
        for(int i = start_chan; i<end_chan; i++) {
            mat_data.at<float>(num_iterations, i-start_chan) = 
                sqrt(fft_out[i][0]*fft_out[i][0] + fft_out[i][1]*fft_out[i][1]);
        }

        // Accumulate the data
        for(int i = 0; i<FFT_SIZE; i++) {
            acc[i] += sqrt(fft_out[i][0]*fft_out[i][0] + fft_out[i][1]*fft_out[i][1]);
        }

        // Move the position forward
        pos += (int)(FFT_SIZE * (1.0-OVERLAP));

        num_iterations++;
    }
    printf("Processed %d iterations\n", num_iterations);

    // Save the accumulated data for analysis in Python
    FILE *accFp = fopen("acc.dat", "w");
    for(int i = 0; i<FFT_SIZE; i++) {
        if(i != FFT_SIZE-1) {
            fprintf(accFp, "%lf,", acc[i]);
        } else {
            fprintf(accFp, "%lf", acc[i]);
        }
    }
    fclose(accFp);

    // Save the raw data
    uchar * arr = mat_data.isContinuous()? mat_data.data: mat_data.clone().data;
    uint length = mat_data.total()*mat_data.channels() * mat_data.elemSize();
    FILE *fp_raw = fopen(FFT_RAW_OUTPUT_FILENAME, "w");
    fwrite(arr, sizeof(uchar), length, fp_raw);
    fclose(fp_raw);

    double minVal, maxVal;
    minMaxIdx(mat_data, &minVal, &maxVal);
    printf("minVal=%lf, maxVal=%lf\n", minVal, maxVal);

    // Scale the data to 0-255
    adjMap.setTo(cv::Scalar::all(0));
    convertScaleAbs(mat_data, adjMap, 255 / maxVal);

    // Apply the color map
    im_color.setTo(cv::Scalar::all(0));
    applyColorMap(adjMap, im_color, COLORMAP_DEEPGREEN);

    // Save the image
    imwrite(FFT_IMAGENAME, im_color);

    //Free the data
    if(fft_data_chunk_from_file != NULL) {
        printf("Freeing fft_data_chunk_from_file\n");
        free(fft_data_chunk_from_file);
    }

    printf("Image name = %s, size=%d x %d pixels, %d bytes per pixel\n", 
            FFT_IMAGENAME, im_color.cols, im_color.rows, length);

    

    /////////////////////
    //PROCESSING FINISHED
    /////////////////////

    printf("Destroying FFT\n");
    fftw_destroy_plan(fft_plan);
    fftw_free(fft_in);
    fftw_free(fft_out);

    // Free the data
    printf("Freeing mat_data, adjMap, im_color \n");
    mat_data.release();
    adjMap.release();
    im_color.release();

    printf("Done\n");

    // We lived! Return success
    return 0;
}
